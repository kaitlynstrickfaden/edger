stop(str_glue("ref_images {ref_images} and length of roi {length(roi)} do not match."))
}
}
# Check if color is a character
if (is.character(color) == FALSE) {
stop("color must be a character string.")
}
# Check if shift is a coordinate pair
if (is.numeric(shift) == FALSE | length(shift) != 2) {
stop("shift must be a numeric vector of length 2.")
}
# Check if threshold value is valid
if (any(th <= 0)) {
stop("th must be a vector of positive non-zero numbers.")
}
rgbcolor <- as.vector(grDevices::col2rgb(color)/255)
ref_ims <- images[1:ref_images]
ROI <- edger_identify(ref_ims = ref_ims,
roi = roi,
th = th,
regions = regions)
im1 <- imager::load.image(images[1])
im1_df <- edger_im_to_df(im1)
m <- edger_match(imdf = im1_df,
roi = ROI,
shift = shift,
rotate = rotate)
im1_new <- edger_recolor(imdf = im1_df,
m = m,
rgbcolor = rgbcolor,
show = TRUE)
im1_newname <- edger_name(images[1])
edger_save(im1_new, im1_newname)
if (process == "sequential") {
message("Recoloring images...")
with_progress({
p <- progressor(steps = length(images[-1]), message = "Recoloring images...")
purrr::map_chr(images[-1], ~{
p()
edger_overlay(.,
m = m,
rgbcolor = rgbcolor,
show_image = show_image)
edger_meta(.)
})
})
}
if (process == "parallel") {
plan(multisession, workers = cores)
options(future.rng.onMisuse = "ignore")
message("Recoloring images...")
with_progress({
p <- progressor(steps = length(images[-1]), message = "Recoloring images...")
furrr::future_map_chr(images[-1], ~{
p()
edger_overlay(.,
m = m,
rgbcolor = rgbcolor,
show_image = show_image)
edger_meta(.)
})
})
}
# message("Attributing metadata...")
#
# with_progress({
#   p <- progressor(steps = length(images), message = "Attributing metadata...")
#
#   purrr::map_chr(images, ~{
#     p()
#   })
# })
Sys.time() - st
}
edger_multi(lf, show_image = F, process = "parallel", cores = 3)
exif_read(edger_name(lf[1]))
edger_multi <- function(images,
ref_images = 1,
roi = NULL,
th = 0.1,
regions = 1,
shift = c(0,0),
rotate = 0,
color = "red",
show_image = TRUE,
process = "sequential",
cores = 1)
{
st <- Sys.time()
# Check if file paths are valid
for (i in seq_along(images)) {
if (file.exists(images[i]) == FALSE) {
stop(str_glue("images[", i, "] is not a valid path.", sep = "")) }
}
# Check if ref_images matches with roi
if (is.null(roi) == FALSE) {
if (ref_images != length(roi)) {
stop(str_glue("ref_images {ref_images} and length of roi {length(roi)} do not match."))
}
}
# Check if color is a character
if (is.character(color) == FALSE) {
stop("color must be a character string.")
}
# Check if shift is a coordinate pair
if (is.numeric(shift) == FALSE | length(shift) != 2) {
stop("shift must be a numeric vector of length 2.")
}
# Check if threshold value is valid
if (any(th <= 0)) {
stop("th must be a vector of positive non-zero numbers.")
}
rgbcolor <- as.vector(grDevices::col2rgb(color)/255)
ref_ims <- images[1:ref_images]
ROI <- edger_identify(ref_ims = ref_ims,
roi = roi,
th = th,
regions = regions)
im1 <- imager::load.image(images[1])
im1_df <- edger_im_to_df(im1)
m <- edger_match(imdf = im1_df,
roi = ROI,
shift = shift,
rotate = rotate)
im1_new <- edger_recolor(imdf = im1_df,
m = m,
rgbcolor = rgbcolor,
show = TRUE)
im1_newname <- edger_name(images[1])
edger_save(im1_new, im1_newname)
if (process == "sequential") {
message("Recoloring images...")
with_progress({
p <- progressor(steps = length(images[-1]), message = "Recoloring images...")
purrr::map_chr(images[-1], ~{
p()
edger_overlay(.,
m = m,
rgbcolor = rgbcolor,
show_image = show_image)
})
message("Attributing metadata...")
with_progress({
p <- progressor(steps = length(images), message = "Attributing metadata...")
purrr::map_chr(images, ~{
p()
edger_meta(.)
})
})
})
}
if (process == "parallel") {
plan(multisession, workers = cores)
options(future.rng.onMisuse = "ignore")
message("Recoloring images...")
with_progress({
p <- progressor(steps = length(images[-1]), message = "Recoloring images...")
furrr::future_map_chr(images[-1], ~{
p()
edger_overlay(.,
m = m,
rgbcolor = rgbcolor,
show_image = show_image)
})
message("Attributing metadata...")
with_progress({
p <- progressor(steps = length(images), message = "Attributing metadata...")
furrr::future_map_chr(images, ~{
p()
edger_meta(.)
})
})
})
}
Sys.time() - st
}
edger_multi(lf, show_image = F, process = "parallel", cores = 3)
library(edger)
edger_multi <- function(images,
ref_images = 1,
roi = NULL,
th = 0.1,
regions = 1,
shift = c(0,0),
rotate = 0,
color = "red",
show_image = TRUE,
process = "sequential",
cores = 1)
{
st <- Sys.time()
# Check if file paths are valid
for (i in seq_along(images)) {
if (file.exists(images[i]) == FALSE) {
stop(str_glue("images[", i, "] is not a valid path.", sep = "")) }
}
# Check if ref_images matches with roi
if (is.null(roi) == FALSE) {
if (ref_images != length(roi)) {
stop(str_glue("ref_images {ref_images} and length of roi {length(roi)} do not match."))
}
}
# Check if color is a character
if (is.character(color) == FALSE) {
stop("color must be a character string.")
}
# Check if shift is a coordinate pair
if (is.numeric(shift) == FALSE | length(shift) != 2) {
stop("shift must be a numeric vector of length 2.")
}
# Check if threshold value is valid
if (any(th <= 0)) {
stop("th must be a vector of positive non-zero numbers.")
}
rgbcolor <- as.vector(grDevices::col2rgb(color)/255)
ref_ims <- images[1:ref_images]
ROI <- edger_identify(ref_ims = ref_ims,
roi = roi,
th = th,
regions = regions)
im1 <- imager::load.image(images[1])
im1_df <- edger_im_to_df(im1)
m <- edger_match(imdf = im1_df,
roi = ROI,
shift = shift,
rotate = rotate)
im1_new <- edger_recolor(imdf = im1_df,
m = m,
rgbcolor = rgbcolor,
show = TRUE)
im1_newname <- edger_name(images[1])
edger_save(im1_new, im1_newname)
if (process == "sequential") {
message("Recoloring images...")
with_progress({
p <- progressor(steps = length(images[-1]))
purrr::map_chr(images[-1], ~{
p()
edger_overlay(.,
m = m,
rgbcolor = rgbcolor,
show_image = show_image)
})
message("Attributing metadata...")
with_progress({
p <- progressor(steps = length(images))
purrr::map_chr(images, ~{
p()
edger_meta(.)
})
})
})
}
if (process == "parallel") {
plan(multisession, workers = cores)
options(future.rng.onMisuse = "ignore")
message("Recoloring images...")
with_progress({
p <- progressor(steps = length(images[-1]))
furrr::future_map_chr(images[-1], ~{
p()
edger_overlay(.,
m = m,
rgbcolor = rgbcolor,
show_image = show_image)
})
message("Attributing metadata...")
with_progress({
p <- progressor(steps = length(images))
furrr::future_map_chr(images, ~{
p()
edger_meta(.)
})
})
})
}
Sys.time() - st
}
edger_multi(lf, show_image = F, process = "parallel", cores = 3)
edger_multi(lf, show_image = F)
?edger_name
exif_read(edger_name(lf[1]))
exif_read(edger_name(lf[2]))
exif_read(edger_name(lf[3]))
edger_multi(lf, show_image = F, process = "parallel", cores = 3)
exif_read(edger_name(lf[1]))
exif_read(edger_name(lf[2]))
exif_read(edger_name(lf[3]))
exif_read((lf[3]))
exif_read(edger_name(lf[3]))
edger_multi <- function(images,
ref_images = 1,
roi = NULL,
th = 0.1,
regions = 1,
shift = c(0,0),
rotate = 0,
color = "red",
show_image = TRUE,
process = "sequential",
cores = 1)
{
st <- Sys.time()
# Check if file paths are valid
for (i in seq_along(images)) {
if (file.exists(images[i]) == FALSE) {
stop(str_glue("images[", i, "] is not a valid path.", sep = "")) }
}
# Check if ref_images matches with roi
if (is.null(roi) == FALSE) {
if (ref_images != length(roi)) {
stop(str_glue("ref_images {ref_images} and length of roi {length(roi)} do not match."))
}
}
# Check if color is a character
if (is.character(color) == FALSE) {
stop("color must be a character string.")
}
# Check if shift is a coordinate pair
if (is.numeric(shift) == FALSE | length(shift) != 2) {
stop("shift must be a numeric vector of length 2.")
}
# Check if threshold value is valid
if (any(th <= 0)) {
stop("th must be a vector of positive non-zero numbers.")
}
rgbcolor <- as.vector(grDevices::col2rgb(color)/255)
ref_ims <- images[1:ref_images]
ROI <- edger_identify(ref_ims = ref_ims,
roi = roi,
th = th,
regions = regions)
im1 <- imager::load.image(images[1])
im1_df <- edger_im_to_df(im1)
m <- edger_match(imdf = im1_df,
roi = ROI,
shift = shift,
rotate = rotate)
im1_new <- edger_recolor(imdf = im1_df,
m = m,
rgbcolor = rgbcolor,
show = TRUE)
im1_newname <- edger_name(images[1])
edger_save(im1_new, im1_newname)
if (process == "sequential") {
message("Recoloring images...")
with_progress({
p <- progressor(steps = length(images[-1]))
purrr::map_chr(images[-1], ~{
p()
edger_overlay(.,
m = m,
rgbcolor = rgbcolor,
show_image = show_image)
})
})
}
if (process == "parallel") {
plan(multisession, workers = cores)
options(future.rng.onMisuse = "ignore")
message("Recoloring images...")
with_progress({
p <- progressor(steps = length(images[-1]))
furrr::future_map_chr(images[-1], ~{
p()
edger_overlay(.,
m = m,
rgbcolor = rgbcolor,
show_image = show_image)
})
})
}
message("Attributing metadata...")
with_progress({
p <- progressor(steps = length(images))
purrr::map_chr(images, ~{
p()
edger_meta(.)
})
})
Sys.time() - st
}
edger_multi(lf, show_image = F, process = "parallel", cores = 3)
library(devtools)
document()
library(markdown)
library(rmarkdown)
render("vignettes/edger_use.RMD", output_format = "github_document")
render("vignettes/edger_use.RMD", output_format = "github_document")
document()
document()
check()
check()
install.packages("exiftoolr")
edger_meta <- function(imagepath) {
# Check if file path is valid
if (file.exists(imagepath) == FALSE) {
stop(str_glue("{imagepath} is not a valid path.", sep = "")) }
system2("exiftool", str_glue("-exif:all= -tagsfromfile {imagepath} -all:all -overwrite_original -o {edger_name(imagepath)}"), stdout = TRUE)
} # End of function
devtools::install_github("kaitlynstrickfaden/edger", build_vignettes = T, force = T)
library(edger)
library(imager)
library(tidyverse)
lf <- list.files("C://Users/stri7929/Documents/test")
lf <- str_c("C://Users/stri7929/Documents/test", lf, sep = "/")
install.packages(c("amt", "backports", "BH", "brew", "brio", "broom", "carData", "caret", "circular", "class", "cli", "clipr", "cluster", "colorspace", "commonmark", "conquer", "credentials", "DBI", "desc", "deSolve", "devtools", "digest", "dtplyr", "evaluate", "fasttime", "fitdistrplus", "foreach", "foreign", "fs", "gert", "glue", "gmp", "gower", "httpuv", "igraph", "imager", "iterators", "knitr", "lme4", "magrittr", "maptools", "MASS", "Matrix", "memoise", "mgcv", "multcomp", "MuMIn", "nlme", "nloptr", "nnet", "openssl", "pkgbuild", "pkgload", "plyr", "pracma", "processx", "proj4", "quantreg", "raster", "Rcpp", "RcppArmadillo", "Rdpack", "readr", "readxl", "recipes", "remotes", "rgdal", "rgl", "rlang", "rmarkdown", "rpart", "Rttf2pt1", "sass", "sessioninfo", "sf", "spatial", "stringi", "survival", "terra", "testthat", "tidyr", "tiff", "tinytex", "tzdb", "units", "usethis", "uuid", "vctrs", "vroom", "waldo", "withr", "wk", "xfun", "xml2", "yaml"))
install.packages(c("amt", "backports", "BH", "brew", "brio", "broom", "carData", "caret", "circular", "class", "cli", "clipr", "cluster", "colorspace", "commonmark", "conquer", "credentials", "DBI", "desc", "deSolve", "devtools", "digest", "dtplyr", "evaluate", "fasttime", "fitdistrplus", "foreach", "foreign", "fs", "gert", "glue", "gmp", "gower", "httpuv", "igraph", "imager", "iterators", "knitr", "lme4", "magrittr", "maptools", "MASS", "Matrix", "memoise", "mgcv", "multcomp", "MuMIn", "nlme", "nloptr", "nnet", "openssl", "pkgbuild", "pkgload", "plyr", "pracma", "processx", "proj4", "quantreg", "raster", "Rcpp", "RcppArmadillo", "Rdpack", "readr", "readxl", "recipes", "remotes", "rgdal", "rgl", "rlang", "rmarkdown", "rpart", "Rttf2pt1", "sass", "sessioninfo", "sf", "spatial", "stringi", "survival", "terra", "testthat", "tidyr", "tiff", "tinytex", "tzdb", "units", "usethis", "uuid", "vctrs", "vroom", "waldo", "withr", "wk", "xfun", "xml2", "yaml"))
install.packages(c("amt", "backports", "BH", "brew", "brio", "broom", "carData", "caret", "circular", "class", "cli", "clipr", "cluster", "colorspace", "commonmark", "conquer", "credentials", "DBI", "desc", "deSolve", "devtools", "digest", "dtplyr", "evaluate", "fasttime", "fitdistrplus", "foreach", "foreign", "fs", "gert", "glue", "gmp", "gower", "httpuv", "igraph", "imager", "iterators", "knitr", "lme4", "magrittr", "maptools", "MASS", "Matrix", "memoise", "mgcv", "multcomp", "MuMIn", "nlme", "nloptr", "nnet", "openssl", "pkgbuild", "pkgload", "plyr", "pracma", "processx", "proj4", "quantreg", "raster", "Rcpp", "RcppArmadillo", "Rdpack", "readr", "readxl", "recipes", "remotes", "rgdal", "rgl", "rlang", "rmarkdown", "rpart", "Rttf2pt1", "sass", "sessioninfo", "sf", "spatial", "stringi", "survival", "terra", "testthat", "tidyr", "tiff", "tinytex", "tzdb", "units", "usethis", "uuid", "vctrs", "vroom", "waldo", "withr", "wk", "xfun", "xml2", "yaml"))
install.packages(c("amt", "backports", "BH", "brew", "brio", "broom", "carData", "caret", "circular", "class", "cli", "clipr", "cluster", "colorspace", "commonmark", "conquer", "credentials", "DBI", "desc", "deSolve", "devtools", "digest", "dtplyr", "evaluate", "fasttime", "fitdistrplus", "foreach", "foreign", "fs", "gert", "glue", "gmp", "gower", "httpuv", "igraph", "imager", "iterators", "knitr", "lme4", "magrittr", "maptools", "MASS", "Matrix", "memoise", "mgcv", "multcomp", "MuMIn", "nlme", "nloptr", "nnet", "openssl", "pkgbuild", "pkgload", "plyr", "pracma", "processx", "proj4", "quantreg", "raster", "Rcpp", "RcppArmadillo", "Rdpack", "readr", "readxl", "recipes", "remotes", "rgdal", "rgl", "rlang", "rmarkdown", "rpart", "Rttf2pt1", "sass", "sessioninfo", "sf", "spatial", "stringi", "survival", "terra", "testthat", "tidyr", "tiff", "tinytex", "tzdb", "units", "usethis", "uuid", "vctrs", "vroom", "waldo", "withr", "wk", "xfun", "xml2", "yaml"))
install.packages(c("amt", "backports", "BH", "brew", "brio", "broom", "carData", "caret", "circular", "class", "cli", "clipr", "cluster", "colorspace", "commonmark", "conquer", "credentials", "DBI", "desc", "deSolve", "devtools", "digest", "dtplyr", "evaluate", "fasttime", "fitdistrplus", "foreach", "foreign", "fs", "gert", "glue", "gmp", "gower", "httpuv", "igraph", "imager", "iterators", "knitr", "lme4", "magrittr", "maptools", "MASS", "Matrix", "memoise", "mgcv", "multcomp", "MuMIn", "nlme", "nloptr", "nnet", "openssl", "pkgbuild", "pkgload", "plyr", "pracma", "processx", "proj4", "quantreg", "raster", "Rcpp", "RcppArmadillo", "Rdpack", "readr", "readxl", "recipes", "remotes", "rgdal", "rgl", "rlang", "rmarkdown", "rpart", "Rttf2pt1", "sass", "sessioninfo", "sf", "spatial", "stringi", "survival", "terra", "testthat", "tidyr", "tiff", "tinytex", "tzdb", "units", "usethis", "uuid", "vctrs", "vroom", "waldo", "withr", "wk", "xfun", "xml2", "yaml"))
install.packages(c("amt", "backports", "BH", "brew", "brio", "broom", "carData", "caret", "circular", "class", "cli", "clipr", "cluster", "colorspace", "commonmark", "conquer", "credentials", "DBI", "desc", "deSolve", "devtools", "digest", "dtplyr", "evaluate", "fasttime", "fitdistrplus", "foreach", "foreign", "fs", "gert", "glue", "gmp", "gower", "httpuv", "igraph", "imager", "iterators", "knitr", "lme4", "magrittr", "maptools", "MASS", "Matrix", "memoise", "mgcv", "multcomp", "MuMIn", "nlme", "nloptr", "nnet", "openssl", "pkgbuild", "pkgload", "plyr", "pracma", "processx", "proj4", "quantreg", "raster", "Rcpp", "RcppArmadillo", "Rdpack", "readr", "readxl", "recipes", "remotes", "rgdal", "rgl", "rlang", "rmarkdown", "rpart", "Rttf2pt1", "sass", "sessioninfo", "sf", "spatial", "stringi", "survival", "terra", "testthat", "tidyr", "tiff", "tinytex", "tzdb", "units", "usethis", "uuid", "vctrs", "vroom", "waldo", "withr", "wk", "xfun", "xml2", "yaml"))
install.packages(c("amt", "backports", "BH", "brew", "brio", "broom", "carData", "caret", "circular", "class", "cli", "clipr", "cluster", "colorspace", "commonmark", "conquer", "credentials", "DBI", "desc", "deSolve", "devtools", "digest", "dtplyr", "evaluate", "fasttime", "fitdistrplus", "foreach", "foreign", "fs", "gert", "glue", "gmp", "gower", "httpuv", "igraph", "imager", "iterators", "knitr", "lme4", "magrittr", "maptools", "MASS", "Matrix", "memoise", "mgcv", "multcomp", "MuMIn", "nlme", "nloptr", "nnet", "openssl", "pkgbuild", "pkgload", "plyr", "pracma", "processx", "proj4", "quantreg", "raster", "Rcpp", "RcppArmadillo", "Rdpack", "readr", "readxl", "recipes", "remotes", "rgdal", "rgl", "rlang", "rmarkdown", "rpart", "Rttf2pt1", "sass", "sessioninfo", "sf", "spatial", "stringi", "survival", "terra", "testthat", "tidyr", "tiff", "tinytex", "tzdb", "units", "usethis", "uuid", "vctrs", "vroom", "waldo", "withr", "wk", "xfun", "xml2", "yaml"))
library(tidyverse)
library(imager)
library(edger)
edger_meta <- function(imagepath) {
# Check if file path is valid
if (file.exists(imagepath) == FALSE) {
stop(str_glue("{imagepath} is not a valid path.", sep = "")) }
system2("exiftool", str_glue("-exif:all= -tagsfromfile {imagepath} -all:all -overwrite_original {edger_name(imagepath)} -delete_original!"), stdout = TRUE)
} # End of function
lf <- list.files("C://Users/stri7929/Documents/test")
lf <- str_c("C://Users/stri7929/Documents/test", lf)
lf <- str_c("C://Users/stri7929/Documents/test", lf, sep = "/")
lf <- list.files("C://Users/stri7929/Documents/test")
lf <- str_c("C://Users/stri7929/Documents/test", lf, sep = "/")
edger_multi(lf, show_image = F)
edger_meta <- function(imagepath) {
# Check if file path is valid
if (file.exists(imagepath) == FALSE) {
stop(str_glue("{imagepath} is not a valid path.", sep = "")) }
system2("exiftool", str_glue("-exif:all= -tagsfromfile {imagepath} -all:all -overwrite_original {edger_name(imagepath)} -delete_original!"), stdout = TRUE)
} # End of function
edger_meta(lf[1])
edger_meta <- function(imagepath) {
# Check if file path is valid
if (file.exists(imagepath) == FALSE) {
stop(str_glue("{imagepath} is not a valid path.", sep = "")) }
system2("exiftool", str_glue("-exif:all= -tagsfromfile {imagepath} -all:all -overwrite_original {edger_name(imagepath)}"), stdout = TRUE)
system2("exiftool", str_glue("-delete_original! {edger_name(imagepath)} "), stdout = TRUE)
} # End of function
edger_meta(lf[3])
edger_multi(lf, show_image = F)
edger_meta(lf[1])
edger_meta(lf[2])
edger_meta(lf[1])
edger_meta(lf[2])
edger_meta(lf[3])
system("exiftool - v")
system("exiftool - version")
system("exiftool - ver")
system("exiftool", "-v")
system("exiftool")
system("exiftool", "-version")
system2("exiftool", "-version")
system2("exiftool", "-v")
system2("man exiftool")
system2("man exiftoo")
system2("exiftool --version")
system2("man", "exiftool")
system2("man", "exiftoo")
system2("exiftool", "--version")
system2("wmic", "exiftool")
system2("wmic", "product get name")
system2("where", "exiftool")
system2("where", "exiftoo")
as.numeric(system2("where", "exiftool"))
as.numeric(system2("where", "exiftoo"))
(system2("where", "exiftool")) == 0
(system2("where", "exiftool")) == 1
(system2("where", "exiftoo")) == 1
(system2("where", "exiftoo")) == 0
library(devtools)
document()
rm(list = c("edger_meta"))
document()
document()
document()
check()
check()
.Last.error.trace
library(edger)
library(dplyr)
library(imager)
library(progressr)
library(qpdf)
library(stringr)
knitr::opts_chunk$set(
fig.width = 8,
fig.height = 6,
collapse = TRUE,
comment = "#>"
)
im1 <- "../images/image03.jpg"
par(mar = c(0,0,0,0))
plot(imager::load.image(im1), axes = F)
edger::edger_single(im1)
roi1 <- data.frame(x1 = 894, y1 = 538, x2 = 974, y2 = 1219)
edger_single(im1, roi = list(roi1))
(invisible(system2("where", "exiftool")) == 1)
(invisible(system2("where", "exiftool")) == 0)
(invisible(system2("where", "exiftool"))
)
edger::edger_single(im1)
roi1 <- data.frame(x1 = 894, y1 = 538, x2 = 974, y2 = 1219)
edger_single(im1, roi = list(roi1))
check()
document()
check()
library(rmarkdown)
render("vignettes/edger_use.Rmd", output_format = "github_document")

process = "sequential",
cores = 1)
{
st <- Sys.time()
# Check if file paths are valid
for (i in seq_along(images)) {
if (file.exists(images[i]) == FALSE) {
stop(str_glue("images[", i, "] is not a valid path.", sep = "")) }
}
# Check if ref_images matches with roi
if (is.null(roi) == FALSE) {
if (ref_images != length(roi)) {
stop(str_glue("ref_images {ref_images} and length of roi {length(roi)} do not match."))
}
}
# Check if color is a character
if (is.character(color) == FALSE) {
stop("color must be a character string.")
}
# Check if shift is a coordinate pair
if (is.numeric(shift) == FALSE | length(shift) != 2) {
stop("shift must be a numeric vector of length 2.")
}
# Check if threshold value is valid
if (any(th <= 0)) {
stop("th must be a vector of positive non-zero numbers.")
}
rgbcolor <- as.vector(grDevices::col2rgb(color)/255)
ref_ims <- images[1:ref_images]
ROI <- edger_identify(ref_ims = ref_ims,
roi = roi,
th = th,
regions = regions)
im1 <- imager::load.image(images[1])
im1_df <- edger_im_to_df(im1)
m <- edger_match(imdf = im1_df,
roi = ROI,
shift = shift,
rotate = rotate)
im1_new <- edger_recolor(imdf = im1_df,
m = m,
rgbcolor = rgbcolor,
show = TRUE)
im1_newname <- edger_name(images[1])
edger_save(im1_new, im1_newname)
if (process == "sequential") {
message("Recoloring images...")
with_progress({
p <- progressor(steps = length(images[-1]))
purrr::map_chr(images[-1], ~{
p()
edger_overlay(.,
m = m,
rgbcolor = rgbcolor,
show_image = show_image)
})
})
}
if (process == "parallel") {
plan(multisession, workers = cores)
options(future.rng.onMisuse = "ignore")
message("Recoloring images...")
with_progress({
p <- progressor(steps = length(images[-1]))
furrr::future_map_chr(images[-1], ~{
p()
edger_overlay(.,
m = m,
rgbcolor = rgbcolor,
show_image = show_image)
})
})
}
message("Attributing metadata...")
with_progress({
p <- progressor(steps = length(images))
purrr::map_chr(images, ~{
p()
edger_meta(.)
})
})
Sys.time() - st
}
edger_multi(lf, show_image = F, process = "parallel", cores = 3)
library(devtools)
document()
library(markdown)
library(rmarkdown)
render("vignettes/edger_use.RMD", output_format = "github_document")
render("vignettes/edger_use.RMD", output_format = "github_document")
document()
document()
check()
check()
install.packages("exiftoolr")
edger_meta <- function(imagepath) {
# Check if file path is valid
if (file.exists(imagepath) == FALSE) {
stop(str_glue("{imagepath} is not a valid path.", sep = "")) }
system2("exiftool", str_glue("-exif:all= -tagsfromfile {imagepath} -all:all -overwrite_original -o {edger_name(imagepath)}"), stdout = TRUE)
} # End of function
devtools::install_github("kaitlynstrickfaden/edger", build_vignettes = T, force = T)
library(edger)
library(imager)
library(tidyverse)
lf <- list.files("C://Users/stri7929/Documents/test")
lf <- str_c("C://Users/stri7929/Documents/test", lf, sep = "/")
install.packages(c("amt", "backports", "BH", "brew", "brio", "broom", "carData", "caret", "circular", "class", "cli", "clipr", "cluster", "colorspace", "commonmark", "conquer", "credentials", "DBI", "desc", "deSolve", "devtools", "digest", "dtplyr", "evaluate", "fasttime", "fitdistrplus", "foreach", "foreign", "fs", "gert", "glue", "gmp", "gower", "httpuv", "igraph", "imager", "iterators", "knitr", "lme4", "magrittr", "maptools", "MASS", "Matrix", "memoise", "mgcv", "multcomp", "MuMIn", "nlme", "nloptr", "nnet", "openssl", "pkgbuild", "pkgload", "plyr", "pracma", "processx", "proj4", "quantreg", "raster", "Rcpp", "RcppArmadillo", "Rdpack", "readr", "readxl", "recipes", "remotes", "rgdal", "rgl", "rlang", "rmarkdown", "rpart", "Rttf2pt1", "sass", "sessioninfo", "sf", "spatial", "stringi", "survival", "terra", "testthat", "tidyr", "tiff", "tinytex", "tzdb", "units", "usethis", "uuid", "vctrs", "vroom", "waldo", "withr", "wk", "xfun", "xml2", "yaml"))
install.packages(c("amt", "backports", "BH", "brew", "brio", "broom", "carData", "caret", "circular", "class", "cli", "clipr", "cluster", "colorspace", "commonmark", "conquer", "credentials", "DBI", "desc", "deSolve", "devtools", "digest", "dtplyr", "evaluate", "fasttime", "fitdistrplus", "foreach", "foreign", "fs", "gert", "glue", "gmp", "gower", "httpuv", "igraph", "imager", "iterators", "knitr", "lme4", "magrittr", "maptools", "MASS", "Matrix", "memoise", "mgcv", "multcomp", "MuMIn", "nlme", "nloptr", "nnet", "openssl", "pkgbuild", "pkgload", "plyr", "pracma", "processx", "proj4", "quantreg", "raster", "Rcpp", "RcppArmadillo", "Rdpack", "readr", "readxl", "recipes", "remotes", "rgdal", "rgl", "rlang", "rmarkdown", "rpart", "Rttf2pt1", "sass", "sessioninfo", "sf", "spatial", "stringi", "survival", "terra", "testthat", "tidyr", "tiff", "tinytex", "tzdb", "units", "usethis", "uuid", "vctrs", "vroom", "waldo", "withr", "wk", "xfun", "xml2", "yaml"))
install.packages(c("amt", "backports", "BH", "brew", "brio", "broom", "carData", "caret", "circular", "class", "cli", "clipr", "cluster", "colorspace", "commonmark", "conquer", "credentials", "DBI", "desc", "deSolve", "devtools", "digest", "dtplyr", "evaluate", "fasttime", "fitdistrplus", "foreach", "foreign", "fs", "gert", "glue", "gmp", "gower", "httpuv", "igraph", "imager", "iterators", "knitr", "lme4", "magrittr", "maptools", "MASS", "Matrix", "memoise", "mgcv", "multcomp", "MuMIn", "nlme", "nloptr", "nnet", "openssl", "pkgbuild", "pkgload", "plyr", "pracma", "processx", "proj4", "quantreg", "raster", "Rcpp", "RcppArmadillo", "Rdpack", "readr", "readxl", "recipes", "remotes", "rgdal", "rgl", "rlang", "rmarkdown", "rpart", "Rttf2pt1", "sass", "sessioninfo", "sf", "spatial", "stringi", "survival", "terra", "testthat", "tidyr", "tiff", "tinytex", "tzdb", "units", "usethis", "uuid", "vctrs", "vroom", "waldo", "withr", "wk", "xfun", "xml2", "yaml"))
install.packages(c("amt", "backports", "BH", "brew", "brio", "broom", "carData", "caret", "circular", "class", "cli", "clipr", "cluster", "colorspace", "commonmark", "conquer", "credentials", "DBI", "desc", "deSolve", "devtools", "digest", "dtplyr", "evaluate", "fasttime", "fitdistrplus", "foreach", "foreign", "fs", "gert", "glue", "gmp", "gower", "httpuv", "igraph", "imager", "iterators", "knitr", "lme4", "magrittr", "maptools", "MASS", "Matrix", "memoise", "mgcv", "multcomp", "MuMIn", "nlme", "nloptr", "nnet", "openssl", "pkgbuild", "pkgload", "plyr", "pracma", "processx", "proj4", "quantreg", "raster", "Rcpp", "RcppArmadillo", "Rdpack", "readr", "readxl", "recipes", "remotes", "rgdal", "rgl", "rlang", "rmarkdown", "rpart", "Rttf2pt1", "sass", "sessioninfo", "sf", "spatial", "stringi", "survival", "terra", "testthat", "tidyr", "tiff", "tinytex", "tzdb", "units", "usethis", "uuid", "vctrs", "vroom", "waldo", "withr", "wk", "xfun", "xml2", "yaml"))
install.packages(c("amt", "backports", "BH", "brew", "brio", "broom", "carData", "caret", "circular", "class", "cli", "clipr", "cluster", "colorspace", "commonmark", "conquer", "credentials", "DBI", "desc", "deSolve", "devtools", "digest", "dtplyr", "evaluate", "fasttime", "fitdistrplus", "foreach", "foreign", "fs", "gert", "glue", "gmp", "gower", "httpuv", "igraph", "imager", "iterators", "knitr", "lme4", "magrittr", "maptools", "MASS", "Matrix", "memoise", "mgcv", "multcomp", "MuMIn", "nlme", "nloptr", "nnet", "openssl", "pkgbuild", "pkgload", "plyr", "pracma", "processx", "proj4", "quantreg", "raster", "Rcpp", "RcppArmadillo", "Rdpack", "readr", "readxl", "recipes", "remotes", "rgdal", "rgl", "rlang", "rmarkdown", "rpart", "Rttf2pt1", "sass", "sessioninfo", "sf", "spatial", "stringi", "survival", "terra", "testthat", "tidyr", "tiff", "tinytex", "tzdb", "units", "usethis", "uuid", "vctrs", "vroom", "waldo", "withr", "wk", "xfun", "xml2", "yaml"))
install.packages(c("amt", "backports", "BH", "brew", "brio", "broom", "carData", "caret", "circular", "class", "cli", "clipr", "cluster", "colorspace", "commonmark", "conquer", "credentials", "DBI", "desc", "deSolve", "devtools", "digest", "dtplyr", "evaluate", "fasttime", "fitdistrplus", "foreach", "foreign", "fs", "gert", "glue", "gmp", "gower", "httpuv", "igraph", "imager", "iterators", "knitr", "lme4", "magrittr", "maptools", "MASS", "Matrix", "memoise", "mgcv", "multcomp", "MuMIn", "nlme", "nloptr", "nnet", "openssl", "pkgbuild", "pkgload", "plyr", "pracma", "processx", "proj4", "quantreg", "raster", "Rcpp", "RcppArmadillo", "Rdpack", "readr", "readxl", "recipes", "remotes", "rgdal", "rgl", "rlang", "rmarkdown", "rpart", "Rttf2pt1", "sass", "sessioninfo", "sf", "spatial", "stringi", "survival", "terra", "testthat", "tidyr", "tiff", "tinytex", "tzdb", "units", "usethis", "uuid", "vctrs", "vroom", "waldo", "withr", "wk", "xfun", "xml2", "yaml"))
install.packages(c("amt", "backports", "BH", "brew", "brio", "broom", "carData", "caret", "circular", "class", "cli", "clipr", "cluster", "colorspace", "commonmark", "conquer", "credentials", "DBI", "desc", "deSolve", "devtools", "digest", "dtplyr", "evaluate", "fasttime", "fitdistrplus", "foreach", "foreign", "fs", "gert", "glue", "gmp", "gower", "httpuv", "igraph", "imager", "iterators", "knitr", "lme4", "magrittr", "maptools", "MASS", "Matrix", "memoise", "mgcv", "multcomp", "MuMIn", "nlme", "nloptr", "nnet", "openssl", "pkgbuild", "pkgload", "plyr", "pracma", "processx", "proj4", "quantreg", "raster", "Rcpp", "RcppArmadillo", "Rdpack", "readr", "readxl", "recipes", "remotes", "rgdal", "rgl", "rlang", "rmarkdown", "rpart", "Rttf2pt1", "sass", "sessioninfo", "sf", "spatial", "stringi", "survival", "terra", "testthat", "tidyr", "tiff", "tinytex", "tzdb", "units", "usethis", "uuid", "vctrs", "vroom", "waldo", "withr", "wk", "xfun", "xml2", "yaml"))
library(tidyverse)
library(imager)
library(edger)
edger_meta <- function(imagepath) {
# Check if file path is valid
if (file.exists(imagepath) == FALSE) {
stop(str_glue("{imagepath} is not a valid path.", sep = "")) }
system2("exiftool", str_glue("-exif:all= -tagsfromfile {imagepath} -all:all -overwrite_original {edger_name(imagepath)} -delete_original!"), stdout = TRUE)
} # End of function
lf <- list.files("C://Users/stri7929/Documents/test")
lf <- str_c("C://Users/stri7929/Documents/test", lf)
lf <- str_c("C://Users/stri7929/Documents/test", lf, sep = "/")
lf <- list.files("C://Users/stri7929/Documents/test")
lf <- str_c("C://Users/stri7929/Documents/test", lf, sep = "/")
edger_multi(lf, show_image = F)
edger_meta <- function(imagepath) {
# Check if file path is valid
if (file.exists(imagepath) == FALSE) {
stop(str_glue("{imagepath} is not a valid path.", sep = "")) }
system2("exiftool", str_glue("-exif:all= -tagsfromfile {imagepath} -all:all -overwrite_original {edger_name(imagepath)} -delete_original!"), stdout = TRUE)
} # End of function
edger_meta(lf[1])
edger_meta <- function(imagepath) {
# Check if file path is valid
if (file.exists(imagepath) == FALSE) {
stop(str_glue("{imagepath} is not a valid path.", sep = "")) }
system2("exiftool", str_glue("-exif:all= -tagsfromfile {imagepath} -all:all -overwrite_original {edger_name(imagepath)}"), stdout = TRUE)
system2("exiftool", str_glue("-delete_original! {edger_name(imagepath)} "), stdout = TRUE)
} # End of function
edger_meta(lf[3])
edger_multi(lf, show_image = F)
edger_meta(lf[1])
edger_meta(lf[2])
edger_meta(lf[1])
edger_meta(lf[2])
edger_meta(lf[3])
system("exiftool - v")
system("exiftool - version")
system("exiftool - ver")
system("exiftool", "-v")
system("exiftool")
system("exiftool", "-version")
system2("exiftool", "-version")
system2("exiftool", "-v")
system2("man exiftool")
system2("man exiftoo")
system2("exiftool --version")
system2("man", "exiftool")
system2("man", "exiftoo")
system2("exiftool", "--version")
system2("wmic", "exiftool")
system2("wmic", "product get name")
system2("where", "exiftool")
system2("where", "exiftoo")
as.numeric(system2("where", "exiftool"))
as.numeric(system2("where", "exiftoo"))
(system2("where", "exiftool")) == 0
(system2("where", "exiftool")) == 1
(system2("where", "exiftoo")) == 1
(system2("where", "exiftoo")) == 0
library(devtools)
document()
rm(list = c("edger_meta"))
document()
document()
document()
check()
check()
.Last.error.trace
library(edger)
library(dplyr)
library(imager)
library(progressr)
library(qpdf)
library(stringr)
knitr::opts_chunk$set(
fig.width = 8,
fig.height = 6,
collapse = TRUE,
comment = "#>"
)
im1 <- "../images/image03.jpg"
par(mar = c(0,0,0,0))
plot(imager::load.image(im1), axes = F)
edger::edger_single(im1)
roi1 <- data.frame(x1 = 894, y1 = 538, x2 = 974, y2 = 1219)
edger_single(im1, roi = list(roi1))
(invisible(system2("where", "exiftool")) == 1)
(invisible(system2("where", "exiftool")) == 0)
(invisible(system2("where", "exiftool"))
)
edger::edger_single(im1)
roi1 <- data.frame(x1 = 894, y1 = 538, x2 = 974, y2 = 1219)
edger_single(im1, roi = list(roi1))
check()
document()
check()
library(rmarkdown)
render("vignettes/edger_use.Rmd", output_format = "github_document")
edger_identify <- function(ref_ims,
roi = NULL,
th = 20,
regions = 1
)
{
if (length(ref_ims) != length(th)) {
stop("Number of threshold values must equal number of reference images")
}
roi1 <- NULL
for (j in 1:length(ref_ims)) {
im <- imager::load.image(ref_ims[j])
im_bw <- edger_im_to_grad(im)
## Define region of interest if "roi" is not set:
if (is.null(roi) == TRUE) {
for (i in 1:regions) {
im_roi <- imager::grabRect(im, output = "coord")
roi2 <- dplyr::filter(im_bw,
im_bw$x >= im_roi[1] & im_bw$x <= im_roi[3] &
im_bw$y >= im_roi[2] & im_bw$y <= im_roi[4] &
im_bw$value >= (th[j]/200))
roi1 <- rbind(roi1, roi2)
} # End of regions
}
if (is.null(roi) == FALSE) {
for (i in 1:regions) {
im_roi <- as.numeric(roi[[j]][i,])
roi2 <- dplyr::filter(im_bw,
im_bw$x >= im_roi[1] & im_bw$x <= im_roi[3] &
im_bw$y >= im_roi[2] & im_bw$y <= im_roi[4] &
im_bw$value >= (th[j]/200))
roi1 <- rbind(roi1, roi2)
} # End of regions
}
} # End of photos
return(distinct(roi1))
}
edger_multi <- function(images,
ref_images = 1,
roi = NULL,
th = 20,
regions = 1,
shift = c(0,0),
rotate = 0,
color = "red",
show_image = TRUE,
process = "sequential",
cores = 1)
{
st <- Sys.time()
# Check if ExifTool is installed
if (invisible(system2("where", "exiftool")) == 1) {
stop("Could not find installation of ExifTool.")
}
# Check if file paths are valid
for (i in seq_along(images)) {
if (file.exists(images[i]) == FALSE) {
stop(str_glue("images[", i, "] is not a valid path.", sep = "")) }
}
# Check if ref_images matches with roi
if (is.null(roi) == FALSE) {
if (ref_images != length(roi)) {
stop(str_glue("ref_images {ref_images} and length of roi {length(roi)} do not match."))
}
}
# Check if color is a character
if (is.character(color) == FALSE) {
stop("color must be a character string.")
}
# Check if shift is a coordinate pair
if (is.numeric(shift) == FALSE | length(shift) != 2) {
stop("shift must be a numeric vector of length 2.")
}
# Check if threshold value is valid
if (any(th <= 0)) {
stop("th must be a vector of positive non-zero numbers.")
}
rgbcolor <- as.vector(grDevices::col2rgb(color)/255)
ref_ims <- images[1:ref_images]
ROI <- edger_identify(ref_ims = ref_ims,
roi = roi,
th = th,
regions = regions)
im1 <- imager::load.image(images[1])
im1_df <- edger_im_to_df(im1)
m <- edger_match(imdf = im1_df,
roi = ROI,
shift = shift,
rotate = rotate)
im1_new <- edger_recolor(imdf = im1_df,
m = m,
rgbcolor = rgbcolor,
show = TRUE)
im1_newname <- edger_name(images[1])
edger_save(im1_new, im1_newname)
if (process == "sequential") {
message("Recoloring images...")
with_progress({
p <- progressor(steps = length(images[-1]))
purrr::map_chr(images[-1], ~{
p()
edger_overlay(.,
m = m,
rgbcolor = rgbcolor,
show_image = show_image)
})
})
}
if (process == "parallel") {
plan(multisession, workers = cores)
options(future.rng.onMisuse = "ignore")
message("Recoloring images...")
with_progress({
p <- progressor(steps = length(images[-1]))
furrr::future_map_chr(images[-1], ~{
p()
edger_overlay(.,
m = m,
rgbcolor = rgbcolor,
show_image = show_image)
})
})
}
message("Attributing metadata...")
with_progress({
p <- progressor(steps = length(images))
purrr::map_chr(images, ~{
p()
edger_meta(.)
})
})
Sys.time() - st
}
edger_testr <- function(imagepaths, regions = 1, color = "red") {
if (is.vector(imagepaths) == FALSE | is.character(imagepaths) == FALSE) {
stop("'imagepaths' must be a character vector")
}
roi <- list()
th <- c()
sh <- list()
ro <- c()
for (j in seq_along(imagepaths)) {
refimage <- imagepaths[j]
if (file.exists(refimage) == FALSE) {
stop(str_glue("imagepaths[", j, "] is not a valid path.", sep = "")) }
roi_d <- data.frame()
for (i in 1:regions) {
thdone <- FALSE
tv <- 20
shdone <- FALSE
shf <- c(0,0)
rodone <- FALSE
rot <- 0
roi_in <- grabRect(imager::load.image(refimage), output = "coord")
roi_in <- data.frame(x0 = roi_in[1], y0 = roi_in[2],
x1 = roi_in[3], y1 = roi_in[4])
edger_single(refimage,
roi = list(roi_in),
th = tv,
shift = shf,
rotate = rot,
regions = regions,
color = color)
while (thdone == FALSE) {
interactive()
x <- readline(prompt = "Is this a good threshold value? Input Y for yes or N for no: ")
if (x == "Y") {
roi_d <- rbind(roi_d, roi_in)
th <- c(th, tv)
thdone <- TRUE
}
if (x != "Y") {
tvnew <- readline(prompt = str_glue("Current threshold value: {tv}  Input new threshold value: "))
while (suppressWarnings(is.na(as.numeric(tvnew))) == TRUE |
suppressWarnings(as.numeric(tvnew)) <= 0) {
tvnew <- readline(prompt = str_glue("Not a valid input. Please input a number between 1-100.  Current threshold value: {tv}  Input new threshold value: "))
}
tv <- as.numeric(tvnew)
edger_single(refimage, roi = list(roi_in),
th = tv, color = color)
thdone <- FALSE
}
} # end of th while loop
while (rodone == FALSE) {
interactive()
x <- readline(prompt = "Is this a good rotation value? Input Y for yes or N for no: ")
if (x == "Y") {
ro <- c(ro, rot)
rodone <- TRUE
}
if (x != "Y") {
ronew <- readline(prompt = str_glue("Current rotation value: {rot}  Input new threshold value: "))
while (suppressWarnings(is.na(as.numeric(ronew))) == TRUE) {
ronew <- readline(prompt = str_glue("Not a valid input. Please input a number.  Current threshold value: {rot}  Input new threshold value: "))
}
rot <- as.numeric(ronew)
edger_single(refimage, roi = list(roi_in),
th = tv, shift = shf, rotate = rot, color = color)
rodone <- FALSE
}
} # end of ro while loop
while (shdone == FALSE) {
interactive()
x <- readline(prompt = "Is this a good shift value? Input Y for yes or N for no: ")
if (x == "Y") {
shdone <- TRUE
}
if (x != "Y") {
# x shift
xnew <- readline(prompt = str_glue("Current x shift: {shf[1]}  Input new x shift: "))
while (suppressWarnings(is.na(as.numeric(xnew))) == TRUE) {
xnew <- readline(prompt = str_glue("Not a valid input. Please input a number.  Current x shift: {shf[1]}  Input new x shift: "))
}
xsh <- round(as.numeric(xnew))
shf[1] <- xsh
# y shift
ynew <- readline(prompt = str_glue("Current y shift: {shf[2]}  Input new y shift: "))
while (suppressWarnings(is.na(as.numeric(ynew))) == TRUE) {
ynew <- readline(prompt = str_glue("Not a valid input. Please input a number.  Current y shift: {shf[2]}  Input new y shift: "))
}
ysh <- round(as.numeric(ynew))
shf[2] <- ysh
edger_single(refimage, roi = list(roi_in),
th = tv, shift = shf, color = color)
shdone <- FALSE
}
} # end of sh while loop
} # end of regions loop
roi[[j]] <- roi_d
sh[[j]] <- shf
ro[[j]] <- rot
} # end of images loop
return(list("roi" = roi,"th" = th, "shift" = sh, "rotate" = ro))
} # end of function
edger_single <- function(imagepath,
roi = NULL,
th = 20,
regions = 1,
shift = c(0,0),
rotate = 0,
color = "red",
save = FALSE)
{
if (is.null(roi) == FALSE & is.list(roi) == FALSE) {
stop("roi must be a list object.")
}
if (th <= 0) {
stop("th must be a positive non-zero number.")
}
if (is.character(color) == FALSE) {
stop("color must be a character string.")
}
rgbcolor <- as.vector(grDevices::col2rgb(color)/255)
ROI <- edger_identify(ref_ims = imagepath,
roi = roi,
th = th,
regions = regions)
st <- Sys.time()
im <- imager::load.image(imagepath)
im_df <- edger_im_to_df(im)
m <- edger_match(imdf = im_df,
roi = ROI,
shift = shift,
rotate = rotate)
im_new <- edger_recolor(imdf = im_df,
m = m,
rgbcolor = rgbcolor,
show = TRUE)
## Save new image if save == TRUE
if (save == TRUE) {
if (invisible(system2("where", "exiftool")) == 1) {
stop("Could not find installation of ExifTool.")
}
im_newname <- edger_name(imagepath)
edger_save(im_new, im_newname)
edger_meta(imagepath)
} # End of save == TRUE
round(Sys.time() - st, 2)
}
setwd(C://Users/stri7929/Desktop)
setwd("C://Users/stri7929/Desktop")
ims <- c("00229.jpg", "02838.jpg", "03768.jpg")
edger_single(ims[1])
library(edger)
edger_single(ims[1])
library(tidyverse)
library(imager)
edger_single(ims[1])
library(progressr)
edger_single(ims[1], th = 10)
edger_single(ims[1], th = 30)
edger_testr(ims)
getwd()
check()
library(devtools)
check()
library(rmarkdown)
render("vignettes/edger_use.rmd", output_format = "github_document")
render("vignettes/edger_methodology.rmd", output_format = "github_document")
